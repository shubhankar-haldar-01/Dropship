  app.post('/api/export-workbook', async (req, res) => {
    try {
      const requestSchema = z.object({
        orderDateFrom: z.string(),
        orderDateTo: z.string(),
        deliveredDateFrom: z.string(),
        deliveredDateTo: z.string(),
        dropshipperEmail: z.string().optional(),
      });

      const request = requestSchema.parse(req.body);
      const result = await storage.calculatePayouts(request);

      const productprices = await db.select().from(productPrices);
      const shippingrates = await db.select().from(shippingRates);

      // Create quick lookup maps
      const productMap = new Map(productprices.map((p) => [p.productName, p]));

      const shippingRateMap = new Map<
        number,
        { provider: string; rate: number }
      >();

      shippingrates.forEach((r) => {
        shippingRateMap.set(Number(r.productWeight), {
          provider: r.shippingProvider,
          rate: Number(r.shippingRatePerKg),
        });
      });

      // Create workbook
      const workbook = XLSX.utils.book_new();

      // Summary sheet with comprehensive details
      const summaryData = [
        ['PAYOUT CALCULATION REPORT'],
        ['Generated on:', new Date().toLocaleString('en-IN')],
        [''],
        ['DROPSHIPPER DETAILS'],
        ['Dropshipper Email:', request.dropshipperEmail || 'All Dropshippers'],
        [''],
        ['DATE RANGES'],
        [
          'Order Date Range (for shipping costs):',
          `${request.orderDateFrom} to ${request.orderDateTo}`,
        ],
        [
          'Delivered Date Range (for COD/product costs):',
          `${request.deliveredDateFrom} to ${request.deliveredDateTo}`,
        ],
        [''],
        ['ORDER COUNTS'],
        [
          'Orders with Shipping Charges:',
          result.summary.ordersWithShippingCharges || 0,
        ],
        [
          'Orders with Product Amount:',
          result.summary.ordersWithProductAmount || 0,
        ],
        [''],
        ['FINANCIAL BREAKDOWN'],
        ['Metric', 'Amount (Rs.)', 'Description'],
        [
          'Total Shipping Charges',
          result.summary.shippingTotal,
          'Based on order date range, cancelled orders excluded',
        ],
        [
          'Total COD Received',
          result.summary.codTotal,
          'From delivered orders in delivered date range',
        ],
        [
          'Total Product Cost',
          result.summary.productCostTotal,
          'Product costs for delivered orders',
        ],
        [
          'RTS/RTO Reversal',
          result.summary.rtsRtoReversalTotal,
          'Deductions for returned orders',
        ],
        [''],
        [
          'FINAL PAYOUT',
          result.summary.finalPayable,
          'COD - Product Cost - Shipping - RTS/RTO',
        ],
        [''],
        ['CALCULATION FORMULA'],
        [
          'Final Payout = COD Received - Product Costs - Shipping Charges - RTS/RTO Reversals',
        ],
        [''],
        ['DATA INTEGRITY NOTES'],
        ['• COD amounts preserved exactly from Excel (no rounding)'],
        ['• Shipping costs calculated: Quantity × Weight × Rate per KG'],
        ['• Cancelled orders excluded from shipping calculations'],
        ['• Dual date ranges for accurate cost allocation'],
      ];

      const summarySheet = XLSX.utils.aoa_to_sheet(summaryData);
      XLSX.utils.book_append_sheet(workbook, summarySheet, 'Summary');

      // Order Details sheet
      const orderHeaders = [
        'Order ID',
        'Waybill',
        'Product',
        'SKU/UID',
        'Dropshipper',
        'Order Date',
        'Delivered Date',
        'Shipped Qty',
        'Delivered Qty',
        'COD Rate',
        'COD Received',
        'Shipping Cost',
        'Product Cost',
        'Net Payable',
        'Status',
        'Shipping Provider',
        'Weight (g)',
      ];

      const orderRows = [orderHeaders];

      result.rows.forEach((row) => {
        orderRows.push([
          row.orderId,
          row.waybill || '',
          row.product,
          row.skuUid,
          row.dropshipperEmail,
          row.orderDate
            ? new Date(row.orderDate).toLocaleDateString('en-IN')
            : '',
          row.deliveredDate
            ? new Date(row.deliveredDate).toLocaleDateString('en-IN')
            : '',
          row.shippedQty,
          row.deliveredQty,
          row.codRate,
          row.codReceived,
          row.shippingCost,
          row.productCost,
          row.payable,
          row.status,
          row.shippingProvider,
          row.weight,
        ]);
      });

      const orderSheet = XLSX.utils.aoa_to_sheet(orderRows);
      XLSX.utils.book_append_sheet(workbook, orderSheet, 'All Orders');

      // Shipping Details sheet
      const shippingHeaders = [
        'Order ID',
        'Waybill',
        'Product',
        'Dropshipper',
        'Shipping Provider',
        'Order Date',
        'Quantity',
        // 'Weight per Unit (g)',
        'Total Weight (g)',
        // 'Rate per KG (Rs.)',
        'Shipping Cost (Rs.)',
        'Status',
        'Included in Calculation',
      ];

      const shippingRows = [shippingHeaders];

      // result.rows.forEach((row) => {
      //   const includedInCalc = !row.status.toLowerCase().includes('cancelled')
      //     ? 'YES'
      //     : 'NO (Cancelled)';
      //   shippingRows.push([
      //     row.orderId,
      //     row.waybill || '',
      //     row.product,
      //     row.dropshipperEmail,
      //     row.shippingProvider,
      //     row.orderDate
      //       ? new Date(row.orderDate).toLocaleDateString('en-IN')
      //       : '',
      //     row.qty,
      //     row.productWeight,
      //     row.qty * row.productWeight,
      //     row.shippingRatePerKg || 0,
      //     row.shippingCostCalculated,
      //     row.status,
      //     includedInCalc,
      //   ]);
      // });

      result.rows.forEach((row) => {
        const product = productMap.get(row.product);
        const weightPerUnit = product ? Number(product.productWeight) : 0;

        const rateData = shippingRateMap.get(weightPerUnit);
        const ratePerKg = rateData ? rateData.rate : 0;

        const includedInCalc = !row.status.toLowerCase().includes('cancelled')
          ? 'YES'
          : 'NO (Cancelled)';

        shippingRows.push([
          row.orderId,
          row.waybill || '',
          row.product,
          row.dropshipperEmail,
          row.shippingProvider,
          row.orderDate
            ? new Date(row.orderDate).toLocaleDateString('en-IN')
            : '',
          String(row.shippedQty),
          weightPerUnit.toString(),
          // totalWeight.toString(),
          ratePerKg.toString(),
          // shippingCost.toString(),
          row.status,
          includedInCalc,
        ]);
      });

      const shippingDetailsSheet = XLSX.utils.aoa_to_sheet(shippingRows);
      XLSX.utils.book_append_sheet(
        workbook,
        shippingDetailsSheet,
        'All Shipping Details',
      );

      // COD Details sheet
      const codHeaders = [
        'Order ID',
        'Waybill',
        'Product',
        'Dropshipper',
        'Delivered Date',
        'Delivered Qty',
        'COD Rate (Rs.)',
        'Total COD Received (Rs.)',
        'Status',
        'Included in Calculation',
      ];

      const codRows = [codHeaders];

      result.rows.forEach((row) => {
        const paymentMode = String(row.mode || '')
          .toLowerCase()
          .trim();
        const isCodOrder =
          paymentMode === 'cod' || paymentMode === '' || paymentMode === null;

        if (row.codReceived > 0 && isCodOrder) {
          const includedInCalc = row.status.toLowerCase().includes('delivered')
            ? 'YES'
            : 'NO';
          codRows.push([
            row.orderId,
            row.waybill || '',
            row.product,
            row.dropshipperEmail,
            row.deliveredDate
              ? new Date(row.deliveredDate).toLocaleDateString('en-IN')
              : '',
            row.deliveredQty,
            row.codReceived / (row.deliveredQty || 1),
            row.codReceived,
            row.status,
            includedInCalc,
          ]);
        }
      });

      const codDetailsSheet = XLSX.utils.aoa_to_sheet(codRows);
      XLSX.utils.book_append_sheet(
        workbook,
        codDetailsSheet,
        'All COD Details',
      );

      // Product Cost Details sheet
      const productCostHeaders = [
        'Order ID',
        'Waybill',
        'Product',
        'SKU/UID',
        'Dropshipper',
        'Delivered Qty',
        'Product Cost per Unit (Rs.)',
        'Total Product Cost (Rs.)',
        'Status',
        'Cost Source',
      ];

      const productCostRows = [productCostHeaders];

      result.rows.forEach((row) => {
        if (row.deliveredQty > 0) {
          productCostRows.push([
            row.orderId,
            row.waybill || '',
            row.product,
            row.skuUid,
            row.dropshipperEmail,
            row.deliveredQty,
            row.productCost / (row.deliveredQty || 1),
            row.productCost,
            row.status,
            row.productCost > 0 ? 'Found in Database' : 'Default/Missing',
          ]);
        }
      });

      const productCostDetailsSheet = XLSX.utils.aoa_to_sheet(productCostRows);
      XLSX.utils.book_append_sheet(
        workbook,
        productCostDetailsSheet,
        'All Product Costs',
      );

      // --- START: RESTORED PROVIDER SUMMARY SECTION ---
      const providerSummaryHeaders = [
        'Shipping Provider',
        'Total Orders',
        'Total Quantity',
        'Total Weight (kg)',
        'Rate per KG (Rs.)',
        'Total Shipping Cost (Rs.)',
        'Average Cost per Order',
      ];

      const providerSummaryRows = [providerSummaryHeaders];

      const providerStats = new Map();
      result.rows.forEach((row) => {
        if (
          row.shippingCost > 0 &&
          !row.status.toLowerCase().includes('cancelled')
        ) {
          const provider = row.shippingProvider;
          if (!providerStats.has(provider)) {
            providerStats.set(provider, {
              orders: 0,
              quantity: 0,
              weight: 0,
              cost: 0,
              rate: row.shippingRate || 0,
            });
          }
          const stats = providerStats.get(provider);
          stats.orders += 1;
          stats.quantity += row.shippedQty;
          stats.weight += (row.shippedQty * row.weight) / 1000;
          stats.cost += row.shippingCost;
        }
      });

      providerStats.forEach((stats, provider) => {
        providerSummaryRows.push([
          provider,
          stats.orders,
          stats.quantity,
          stats.weight.toFixed(2),
          stats.rate,
          stats.cost.toFixed(2),
          (stats.cost / stats.orders).toFixed(2),
        ]);
      });

      const providerSummarySheet = XLSX.utils.aoa_to_sheet(providerSummaryRows);
      XLSX.utils.book_append_sheet(
        workbook,
        providerSummarySheet,
        'Provider Summary',
      );
      // --- END: RESTORED PROVIDER SUMMARY SECTION ---

      // --- All other sections like Legacy Details are now restored below ---

      if (result.rows.length > 0) {
        const detailsData = result.rows.map((row) => ({
          'Order ID': row.orderId,
          Waybill: row.waybill || '',
          'Product Name': row.productName,
          'Product UID': row.productUid,
          'Dropshipper Email': row.dropshipperEmail,
          'COD Amount (Rs.)': row.codReceived || 0,
          'Product Cost per Unit': row.productCostPerUnit || 0,
          'Product Weight (kg)': row.productWeight || 0.5,
          'Shipping Rate (per kg)': row.shippingRatePerKg || 0,
          'Shipping Cost (Rs.)': row.shippingCostCalculated || 0,
          Quantity: row.qty,
          Status: row.status,
          'Order Date': row.orderDate,
          'Delivered Date': row.deliveredDate || '',
          'Shipping Provider': row.shippingProvider,
          'Price Found':
            typeof row.mappingStatus === 'object' &&
            row.mappingStatus?.priceFound
              ? 'Yes'
              : 'No',
          'Rate Found':
            typeof row.mappingStatus === 'object' &&
            row.mappingStatus?.rateFound
              ? 'Yes'
              : 'No',
          'COD Valid':
            typeof row.mappingStatus === 'object' && row.mappingStatus?.codValid
              ? 'Yes'
              : 'No',
        }));

        const detailsSheet = XLSX.utils.json_to_sheet(detailsData);
        XLSX.utils.book_append_sheet(workbook, detailsSheet, 'Legacy Details');
      }

      const shippingBreakdown = [
        ['SHIPPING CALCULATION BREAKDOWN'],
        [
          'Order Date Range:',
          `${request.orderDateFrom} to ${request.orderDateTo}`,
        ],
        ['Cancelled orders excluded from shipping calculations'],
        [''],
        [
          'Shipping Provider',
          'Order Count',
          'Total Weight (kg)',
          'Rate per kg',
          'Total Cost (Rs.)',
        ],
      ];

      const shippingByProvider = new Map();
      result.rows.forEach((row) => {
        if (row.shippingCostCalculated > 0) {
          const provider = row.shippingProvider;
          if (!shippingByProvider.has(provider)) {
            shippingByProvider.set(provider, {
              count: 0,
              totalWeight: 0,
              rate: row.shippingRatePerKg,
              totalCost: 0,
            });
          }
          const data = shippingByProvider.get(provider);
          data.count += row.qty;
          data.totalWeight += row.qty * (row.productWeight || 0.5);
          data.totalCost += row.shippingCostCalculated;
        }
      });

      Array.from(shippingByProvider.entries()).forEach(([provider, data]) => {
        shippingBreakdown.push([
          provider,
          data.count,
          data.totalWeight.toFixed(1),
          data.rate,
          data.totalCost.toFixed(2),
        ]);
      });

      const shippingSheet = XLSX.utils.aoa_to_sheet(shippingBreakdown);
      XLSX.utils.book_append_sheet(
        workbook,
        shippingSheet,
        'Shipping Breakdown',
      );

      if (result.adjustments.length > 0) {
        const adjustmentSheet = XLSX.utils.json_to_sheet(
          result.adjustments.map((adj) => ({
            'Order ID': adj.orderId,
            Reason: adj.reason,
            'Amount (Rs.)': adj.amount,
            Reference: adj.reference,
          })),
        );
        XLSX.utils.book_append_sheet(workbook, adjustmentSheet, 'Adjustments');
      }

      const buffer = XLSX.write(workbook, { type: 'buffer', bookType: 'xlsx' });

      const dropshipperPrefix = request.dropshipperEmail
        ? request.dropshipperEmail.replace('@', '_').replace('.', '_')
        : 'all';
      const datePrefix = request.orderDateFrom.replace(/-/g, '');
      const filename = `Payout-Report-${dropshipperPrefix}-${datePrefix}.xlsx`;

      res.setHeader(
        'Content-Disposition',
        `attachment; filename="${filename}"`,
      );
      res.setHeader(
        'Content-Type',
        'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      );
      res.send(buffer);
    } catch (error) {
      console.error('Error exporting workbook:', error);
      res.status(500).json({ message: 'Error exporting workbook' });
    }
  });